pHeader;


%% Adaptation is distinct from receptor saturation 
% First, we constructed a nonlinear-linear-nonlinear model (a-c). (a) The input nonlinearity is a Hill function, with a $K_D$ chosen so that the stimuli we used straddle it. (b) shows the filter used in this model, which is the filter calculated from ORNs stimulated with Gaussian noise inputs. (c) is a simple rectifying output nonlinearity, since ORN responses cannot be negative. (d-f) Analysis of response generated by this model to naturalistic stimulus from Fig. 2, identical to how we analyzed the real data. (d) Filter estimated from nat. stim. (red) compared to actual filter in model. (e) Comparison of model response to stimulus projected through the reconstructed filter. (f) Per-whiff gain varies non-monotonically with the mean stimulus in the preceding 300 ms (cf. Fig 2e). (g-i) Analysis of NLN model response to stimuli with increasing mean from Fig. 1, identical to how we analyzed the real data. (g) Filters reliably extracted. Colors correspond to mean stimulus (as in Fig. 1). (h) Comparison of model responses to stimulus projected through reconstructed filters on a trial-wise basis. Note that all curves lie along a single curve (cf. Fig. 1e) (i) Gain vs. mean stimulus. 


% get the filter from the Gaussian stimuli 
clear MSGdata
MSGdata = consolidateData2(getPath(dataManager,'93ba5d68174e3df9f462a1fc48c581da'));
MSGdata = cleanMSGdata(MSGdata);
MSG_filter = MSGdata.K2(:,MSGdata.paradigm==1);
MSGdata.K = mean(MSG_filter(:,[2 5]),2);
MSGdata.filtertime = 1e-3*(1:length(MSGdata.K)) - .1;

% get the naturalistic stimuli 

clear ab3 ab2
load(getPath(dataManager,'5c7dacc5b42ff0eebb980d80fec120c3'),'data','spikes')
PID = data(2).PID;
time = 1e-4*(1:length(PID));
all_spikes = spikes(2).A;

% A spikes --> firing rate
fA = spiketimes2f(all_spikes,time);

tA = 1e-3*(1:length(fA));
PID2 = fA;
for i = 1:width(PID2)
	PID2(:,i) = interp1(time,PID(i,:),tA);
end
PID = PID2; clear PID2
% some minor cleaning up
PID(end,:) = PID(end-1,:); 

% remove the baseline from the PID, and remember the error
PID_baseline = mean(mean(PID(1:5e3,:)));
PID = PID - PID_baseline;

NSdata.fA = mean(fA,2);
NSdata.PID = mean(PID,2);
NSdata.time = 1e-3*(1:length(NSdata.fA));

% generate an input nonlinearity 

all_k_d = [5e-1 1e-1 1 10];


for ki = 1:length(all_k_d)

	hill_param = [1 all_k_d(ki) 1];
	x = logspace(-2,1,100);
	H = hill(hill_param,x);


	figure('outerposition',[0 0 901 899],'PaperUnits','points','PaperSize',[901 899]); hold on
	clear ax
	for i = 9:-1:1
		ax(i) = subplot(3,3,i); hold on
	end


	plot(ax(1),x,H,'k')
	xlabel(ax(1),'Stimulus (a.u.)')
	ylabel(ax(1),'H(s)')
	set(ax(1),'XScale','log','YScale','linear')


	plot(ax(2),MSGdata.filtertime,MSGdata.K,'k')
	xlabel(ax(2),'Filter lag (s)')
	ylabel(ax(2),'Filter amplitude (a.u.)')

	x = linspace(-1,1,100);
	y = x; y(x<0) = 0;
	plot(ax(3),x,y,'k')
	xlabel(ax(3),'x(t)')
	ylabel(ax(3),'R(t)')


	% first do nat. stim. -- play the stimulus to the NL model. 
	history_length = 300;
	y = hill(hill_param,NSdata.PID);
	NSdata.NL_pred = convolve(NSdata.time,y,MSGdata.K,MSGdata.filtertime);
	NSdata.NL_pred(NSdata.NL_pred<0) = 0;

	% now fit a filter to this data
	NSdata.Khat = fitFilter2Data(NSdata.PID,NSdata.NL_pred,'reg',1,'offset',100,'filter_length',700);

	% compare reconstructed filter to actual filter
	plot(ax(4),MSGdata.filtertime,MSGdata.K,'k')
	xlabel(ax(4),'Filter lag (s)')
	ylabel(ax(4),'Filter amplitude (a.u.)')
	plot(ax(4),MSGdata.filtertime,NSdata.Khat,'r')
	legend(ax(4),'Actual filter','reconstructed filter')

	% reproject
	NSdata.K_pred = convolve(NSdata.time,NSdata.PID,NSdata.Khat,MSGdata.filtertime);

	shat = computeSmoothedStimulus(NSdata.PID,history_length);
	shat = shat-min(shat);
	shat = shat/max(shat);
	shat = 1+ceil(shat*99);
	shat(isnan(shat)) = 1;

	% make the output analysis plot
	axes(ax(5))
	cc = parula(100);
	c = cc(shat,:);
	scatter(NSdata.K_pred,NSdata.NL_pred,20,c,'filled')

	shat = computeSmoothedStimulus(NSdata.PID,history_length);
	ch = colorbar('east');
	ch.Position = [0.582    0.45    0.01    0.06];
	caxis([min(shat) max(shat)]);

	xlabel(ax(5),'Projected Stimulus (a.u.)')
	ylabel(ax(5),'NL model response (a.u.)')



	% find all excursions (defined as firing rate crossing 10Hz)
	[whiff_starts,whiff_ends] = findWhiffs(NSdata.PID);

	d = finddelay(NSdata.PID(58e3:65e3),NSdata.NL_pred(58e3:65e3));
	whiff_starts = whiff_starts + d;
	whiff_ends = whiff_ends + d;

	% filter the stimulus using a box filter
	shat_mean = computeSmoothedStimulus(NSdata.PID,history_length);

	% for each excursion, estimate mean, std stimulus, gain, etc. 
	mean_stim = NaN*whiff_ends;
	gain = NaN*whiff_ends;
	gain_err =  NaN*whiff_ends;
	for i = 1:length(whiff_ends)
		mean_stim(i) = mean(shat_mean(whiff_starts(i):whiff_ends(i)));
		ff = fit(NSdata.K_pred(whiff_starts(i):whiff_ends(i)),NSdata.NL_pred(whiff_starts(i):whiff_ends(i)),'poly1');
		gain(i) = ff.p1;
		temp = confint(ff);
		gain_err(i) = diff(temp(:,1))/2;
	end
	rm_this = (abs(gain_err./gain)) > .5; % throw out points where the estimate of gain has a more than 50% error
	gain(rm_this) = [];
	gain_err(rm_this) = [];
	mean_stim(rm_this) = [];
	whiff_ends(rm_this) = [];
	whiff_starts(rm_this) = [];


	plot(ax(6),mean_stim,gain,'k+')
	xlabel(ax(6),'Mean stimulus in preceding 300ms (V)')
	ylabel(ax(6),'Gain in whiff (a.u.)')
	set(ax(6),'XScale','log','YScale','log')


	% now do the MSG 

	% ##     ##  ######   ######   
	% ###   ### ##    ## ##    ##  
	% #### #### ##       ##        
	% ## ### ##  ######  ##   #### 
	% ##     ##       ## ##    ##  
	% ##     ## ##    ## ##    ##  
	% ##     ##  ######   ######   


	% average stimulus for each paradigm value, and then play that through the model
	MSGdata.time = 1e-3*(1:length(MSGdata.PID));
	for i = 1:length(MSGdata.paradigm)
		MSGdata.NL_pred(:,i) = hill(hill_param,MSGdata.PID(:,i));
		MSGdata.NL_pred(:,i) = convolve(MSGdata.time,MSGdata.NL_pred(:,i),MSGdata.K,MSGdata.filtertime);
		MSGdata.NL_pred(MSGdata.NL_pred(:,i)<0,i) = 0;
	end

	% recover filters for every trial
	for i = 1:length(MSGdata.paradigm)
		MSGdata.Khat(:,i) = fitFilter2Data(MSGdata.PID(35e3:55e3,i),MSGdata.NL_pred(35e3:55e3,i),'reg',1,'offset',100,'filter_length',700);
		MSGdata.Khat(:,i) = MSGdata.Khat(:,i)/norm(MSGdata.Khat(:,i));
		MSGdata.Khat(:,i) = MSGdata.Khat(:,i)*norm(MSGdata.K);
	end


	% compare reconstructed filter to actual filter
	plot(ax(7),MSGdata.filtertime,MSGdata.K,'k')
	xlabel(ax(7),'Filter lag (s)')
	ylabel(ax(7),'Filter amplitude (a.u.)')
	c = parula(11);
	for i = 1:max(MSGdata.paradigm)
		plot(ax(7),MSGdata.filtertime,mean(MSGdata.Khat(:,MSGdata.paradigm==i),2),'Color',c(i,:))
	end

	% reproject all the stimuli
	for i = 1:length(MSGdata.paradigm)
		MSGdata.K_pred(:,i) = convolve(MSGdata.time,MSGdata.PID(:,i),MSGdata.Khat(:,i),MSGdata.filtertime);
	end

	% make i/o curves for different mean stimuli and compute gain in each paradigm 
	axes(ax(8)), hold(ax(8),'on')
	for i = 1:max(MSGdata.paradigm)
		x = mean(MSGdata.K_pred(35e3:55e3,MSGdata.paradigm==i),2);
		y = mean(MSGdata.NL_pred(35e3:55e3,MSGdata.paradigm==i),2);

		% s = nanmean(MSGdata.PID(:,MSGdata.paradigm==i),2);
		% x = x - nanmean(x);
		% x = x + nanmean(nanmean(s));

		plotPieceWiseLinear(x,y,'nbins',50,'Color',c(i,:),'show_error',false,'LineWidth',2);
		
	end
	xlabel(ax(8),'Projected Stimulus (a.u.)')
	ylabel(ax(8),'R (a.u.)')

	for i = 1:length(MSGdata.paradigm)
		x = MSGdata.K_pred(35e3:55e3,i);
		y = MSGdata.NL_pred(35e3:55e3,i);
		ff = fit(x(:),y(:),'poly1');
		MSGdata.NL_gain(i) = ff.p1;
	end

	mean_stim = mean(MSGdata.PID(35e3:55e3,:));
	for i = 1:max(MSGdata.paradigm)
		plot(ax(9),mean_stim(MSGdata.paradigm == i), MSGdata.NL_gain(MSGdata.paradigm==i),'+','Color',c(i,:))
	end
	set(ax(9),'XScale','log','YScale','log','XLim',[.1 2],'YLim',[1e-2 2],'XTick',[.1 .2 .5 1])
	xlabel(ax(9),'Mean stimulus (V)')
	ylabel(ax(9),'Gain (a.u.)')

	prettyFig('fs',12)

	labelFigure

	suptitle(['k_D = ' oval(all_k_d(ki))])

	drawnow

	if being_published	
		snapnow	
		delete(gcf)
	end

end


%% Version Info
%
pFooter;


