pHeader;


%% Adaptation is distinct from receptor saturation 
% In this paper, we characterized adaptation processes in ORNs using LN modeling. LN models are phenomenological, not mechanistic models. While there is an intrinsic front-end nonlinearity in the ORN due to receptor kinetics, we show here that the adaptation mechanisms we characterize are distinct from, and do not arise from, saturation or nonlinearities in receptor activation. First, we constructed a nonlinear-linear-nonlinear model (a-c). (a) The input nonlinearity is a Hill function, with a $K_D$ chosen so that the stimuli we used straddle it. (b) shows the filter used in this model, which is the filter calculated from ORNs stimulated with Gaussian noise inputs. (c) is a simple rectifying output nonlinearity, since ORN responses cannot be negative. (d-f) Analysis of response generated by this model to naturalistic stimulus from Fig. 2, identical to how we analyzed the real data. (d) Filter is reliably reconstructed even though the stimulus is far from Gaussian. (e) Comparison of model response to stimulus projected through the reconstructed filter. All excursions occur roughly with the same slope (cf. Fig 2d). (f) Per-whiff gain is uncorrelated with the mean stimulus in the preceding 300 ms, and does not change dramatically (cf. Fig 2e). (g-i) Analysis of NLN model response to stimuli with increasing mean from Fig. 1, identical to how we analyzed the real data. (g) Filters reliably extracted. Colors correspond to mean stimulus (as in Fig. 1). (h) Comparison of model responses to stimulus projected through reconstructed filters on a trial-wise basis. No appreciable change in slope is evident (cf. Fig. 1e). (i) Gain vs. mean stimulus does not follow an inverse relationship. 


% generate an input nonlinearity 

figure('outerposition',[0 0 901 899],'PaperUnits','points','PaperSize',[901 899]); hold on
clear ax
for i = 9:-1:1
	ax(i) = subplot(3,3,i); hold on
end

hill_param = [1 .2 4];
x = logspace(-2,1,100);
H = hill(hill_param,x);

plot(ax(1),x,H,'k')
xlabel(ax(1),'Stimulus (a.u.)')
ylabel(ax(1),'H(s)')
set(ax(1),'XScale','log','YScale','linear')

% get the filter from the Gaussian stimuli 
clear MSGdata
MSGdata = consolidateData2(getPath(dataManager,'93ba5d68174e3df9f462a1fc48c581da'));
MSGdata = cleanMSGdata(MSGdata);
MSG_filter = MSGdata.K2(:,MSGdata.paradigm==1);
MSGdata.K = mean(MSG_filter(:,[2 5]),2);
MSGdata.filtertime = 1e-3*(1:length(MSGdata.K)) - .1;

plot(ax(2),MSGdata.filtertime,MSGdata.K,'k')
xlabel(ax(2),'Filter lag (s)')
ylabel(ax(2),'Filter amplitude (a.u.)')

x = linspace(-1,1,100);
y = x; y(x<0) = 0;
plot(ax(3),x,y,'k')
xlabel(ax(3),'x(t)')
ylabel(ax(3),'R(t)')

% get the naturalistic stimuli 

clear ab3 ab2
load(getPath(dataManager,'5c7dacc5b42ff0eebb980d80fec120c3'),'data','spikes')
PID = data(2).PID;
time = 1e-4*(1:length(PID));
all_spikes = spikes(2).A;

% A spikes --> firing rate
fA = spiketimes2f(all_spikes,time);

tA = 1e-3*(1:length(fA));
PID2 = fA;
for i = 1:width(PID2)
	PID2(:,i) = interp1(time,PID(i,:),tA);
end
PID = PID2; clear PID2
% some minor cleaning up
PID(end,:) = PID(end-1,:); 

% remove the baseline from the PID, and remember the error
PID_baseline = mean(mean(PID(1:5e3,:)));
PID = PID - PID_baseline;

NSdata.fA = mean(fA,2);
NSdata.PID = mean(PID,2);
NSdata.time = 1e-3*(1:length(NSdata.fA));


% get the variance change stimuli 


% first do nat. stim. -- play the stimulus to the NL model. 

y = hill(hill_param,NSdata.PID);
NSdata.NL_pred = convolve(NSdata.time,NSdata.PID,MSGdata.K,MSGdata.filtertime);
NSdata.NL_pred(NSdata.NL_pred<0) = 0;

% now fit a filter to this data
NSdata.Khat = fitFilter2Data(NSdata.PID,NSdata.NL_pred,'reg',1,'offset',100,'filter_length',700);

% compare reconstructed filter to actual filter
plot(ax(4),MSGdata.filtertime,MSGdata.K,'k')
xlabel(ax(4),'Filter lag (s)')
ylabel(ax(4),'Filter amplitude (a.u.)')
plot(ax(4),MSGdata.filtertime,NSdata.Khat,'r')
legend(ax(4),'Actual filter','reconstructed filter')

% reproject
NSdata.K_pred = convolve(NSdata.time,NSdata.PID,NSdata.Khat,MSGdata.filtertime);

plot(ax(5),NSdata.K_pred,NSdata.NL_pred,'k.')
xlabel(ax(5),'Projected Stimulus (a.u.)')
ylabel(ax(5),'NL model response (a.u.)')



% find all excursions (defined as firing rate crossing 10Hz)
[whiff_starts,whiff_ends] = findWhiffs(NSdata.PID);

d = finddelay(NSdata.PID(58e3:65e3),NSdata.NL_pred(58e3:65e3));
whiff_starts = whiff_starts + d;
whiff_ends = whiff_ends + d;

% filter the stimulus using a box filter
shat_mean = computeSmoothedStimulus(NSdata.PID,300);

% for each excursion, estimate mean, std stimulus, gain, etc. 
mean_stim = NaN*whiff_ends;
gain = NaN*whiff_ends;
gain_err =  NaN*whiff_ends;
for i = 1:length(whiff_ends)
	mean_stim(i) = mean(shat_mean(whiff_starts(i):whiff_ends(i)));
	ff = fit(NSdata.K_pred(whiff_starts(i):whiff_ends(i)),NSdata.NL_pred(whiff_starts(i):whiff_ends(i)),'poly1');
	gain(i) = ff.p1;
	temp = confint(ff);
	gain_err(i) = diff(temp(:,1))/2;
end
rm_this = (abs(gain_err./gain)) > .5; % throw out points where the estimate of gain has a more than 50% error
gain(rm_this) = [];
gain_err(rm_this) = [];
mean_stim(rm_this) = [];
whiff_ends(rm_this) = [];
whiff_starts(rm_this) = [];

plot(ax(6),mean_stim,gain,'k+')
xlabel(ax(6),'Mean stimulus in preceding 300ms (V)')
ylabel(ax(6),'Gain in whiff (a.u.)')
set(ax(6),'XScale','log','YScale','log','YLim',[.1 10])

% now do the MSG 

% average stimulus for each paradigm value, and then play that through the model
MSGdata.time = 1e-3*(1:length(MSGdata.PID));
for i = 1:length(MSGdata.paradigm)
	MSGdata.NL_pred(:,i) = hill(hill_param,MSGdata.PID(:,i));
	MSGdata.NL_pred(:,i) = convolve(MSGdata.time,MSGdata.PID(:,i),MSGdata.K,MSGdata.filtertime);
end

% recover filters for every trial
for i = 1:length(MSGdata.paradigm)
	MSGdata.Khat(:,i) = fitFilter2Data(MSGdata.PID(35e3:55e3,i),MSGdata.NL_pred(35e3:55e3,i),'reg',1,'offset',100,'filter_length',700);
	MSGdata.Khat(:,i) = MSGdata.Khat(:,i)/norm(MSGdata.Khat(:,i));
	MSGdata.Khat(:,i) = MSGdata.Khat(:,i)*norm(MSGdata.K);
end


% compare reconstructed filter to actual filter
plot(ax(7),MSGdata.filtertime,MSGdata.K,'k')
xlabel(ax(7),'Filter lag (s)')
ylabel(ax(7),'Filter amplitude (a.u.)')
c = parula(11);
for i = 1:max(MSGdata.paradigm)
	plot(ax(7),MSGdata.filtertime,mean(MSGdata.Khat(:,MSGdata.paradigm==i),2),'Color',c(i,:))
end

% reproject all the stimuli
for i = 1:length(MSGdata.paradigm)
	MSGdata.K_pred(:,i) = convolve(MSGdata.time,MSGdata.PID(:,i),MSGdata.Khat(:,i),MSGdata.filtertime);
end

% make i/o curves for different mean stimuli and compute gain in each paradigm 
axes(ax(8)), hold(ax(8),'on')
for i = 1:max(MSGdata.paradigm)
	x = mean(MSGdata.K_pred(35e3:55e3,MSGdata.paradigm==i),2);
	y = mean(MSGdata.NL_pred(35e3:55e3,MSGdata.paradigm==i),2);
	plotPieceWiseLinear(x,y,'nbins',50,'Color',c(i,:),'show_error',false,'LineWidth',2);
	
end
xlabel(ax(8),'Projected Stimulus (a.u.)')
ylabel(ax(8),'R (a.u.)')

for i = 1:length(MSGdata.paradigm)
	x = MSGdata.K_pred(35e3:55e3,i);
	y = MSGdata.NL_pred(35e3:55e3,i);
	ff = fit(x(:),y(:),'poly1');
	MSGdata.NL_gain(i) = ff.p1;
end

mean_stim = mean(MSGdata.PID(35e3:55e3,:));
for i = 1:max(MSGdata.paradigm)
	plot(ax(9),mean_stim(MSGdata.paradigm == i), MSGdata.NL_gain(MSGdata.paradigm==i),'+','Color',c(i,:))
end
set(ax(9),'XScale','log','YScale','log','XLim',[.1 2],'YLim',[.1 2],'XTick',[.1 .2 .5 1],'YTick',[.1 .2 .5 1])
xlabel(ax(9),'Mean stimulus (V)')
ylabel(ax(9),'Gain (a.u.)')

prettyFig('fs',12)

labelFigure

if being_published	
	snapnow	
	delete(gcf)
end


%% Version Info
%
pFooter;


